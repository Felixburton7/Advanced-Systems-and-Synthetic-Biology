<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<!--
generated by Pygments <https://pygments.org/>
Copyright 2006-2022 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
-->
<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
/*
generated by Pygments <https://pygments.org/>
Copyright 2006-2022 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
*/
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
body .hll { background-color: #ffffcc }
body { background: #ffffff; }
body .c { color: #888888 } /* Comment */
body .err { color: #FF0000; background-color: #FFAAAA } /* Error */
body .k { color: #008800; font-weight: bold } /* Keyword */
body .o { color: #333333 } /* Operator */
body .ch { color: #888888 } /* Comment.Hashbang */
body .cm { color: #888888 } /* Comment.Multiline */
body .cp { color: #557799 } /* Comment.Preproc */
body .cpf { color: #888888 } /* Comment.PreprocFile */
body .c1 { color: #888888 } /* Comment.Single */
body .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
body .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #333399; font-weight: bold } /* Keyword.Type */
body .m { color: #6600EE; font-weight: bold } /* Literal.Number */
body .s { background-color: #fff0f0 } /* Literal.String */
body .na { color: #0000CC } /* Name.Attribute */
body .nb { color: #007020 } /* Name.Builtin */
body .nc { color: #BB0066; font-weight: bold } /* Name.Class */
body .no { color: #003366; font-weight: bold } /* Name.Constant */
body .nd { color: #555555; font-weight: bold } /* Name.Decorator */
body .ni { color: #880000; font-weight: bold } /* Name.Entity */
body .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
body .nf { color: #0066BB; font-weight: bold } /* Name.Function */
body .nl { color: #997700; font-weight: bold } /* Name.Label */
body .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
body .nt { color: #007700 } /* Name.Tag */
body .nv { color: #996633 } /* Name.Variable */
body .ow { color: #000000; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
body .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
body .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
body .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
body .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
body .sa { background-color: #fff0f0 } /* Literal.String.Affix */
body .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
body .sc { color: #0044DD } /* Literal.String.Char */
body .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
body .sd { color: #DD4422 } /* Literal.String.Doc */
body .s2 { background-color: #fff0f0 } /* Literal.String.Double */
body .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
body .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
body .si { background-color: #eeeeee } /* Literal.String.Interpol */
body .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
body .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
body .s1 { background-color: #fff0f0 } /* Literal.String.Single */
body .ss { color: #AA6600 } /* Literal.String.Symbol */
body .bp { color: #007020 } /* Name.Builtin.Pseudo */
body .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
body .vc { color: #336699 } /* Name.Variable.Class */
body .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
body .vi { color: #3333BB } /* Name.Variable.Instance */
body .vm { color: #996633 } /* Name.Variable.Magic */
body .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;Summary of the process (My Attempt) </span>

<span class="sd">This script decodes DNA droplet information back to its original message. It begins by loading and parsing the luby_blocks.csv file to identify which blocks of information are encoded in each droplet. It then decodes the DNA sequences from the droplet_sequences.fasta file (dropley_sequences.txt file in this case) into binary format using a specified encoding scheme (A -&gt; 00, G -&gt; 01, C -&gt; 10, T -&gt; 11). Each droplet&#39;s binary sequence is divided into three parts: Luby Index (16 bits), Droplet Message (256 bits), and Error Correction Code (16 bits). The Luby Index and Droplet Message are extracted and stored.</span>

<span class="sd">Using the Luby Transform, the script reconstructs the original blocks from the droplet messages by performing XOR operations where necessary. During the reconstruction, any unexpected DNA bases are ignored, ensuring only valid sequences are processed. The script handles cases where block indices are out of range by skipping those droplets. After decoding each droplet&#39;s message, the script combines the blocks to form the final binary message.</span>

<span class="sd">Finally, the binary message is converted back to text, completing the decoding process. The script prints intermediate steps and final results for verification, including the decoded binary sequences and the final text message. This comprehensive approach ensures accurate reconstruction of the original message from the encoded DNA droplets.</span>


<span class="sd">Goal: Decode the DNA droplet information back to the original message by reversing the Luby Transform.</span>

<span class="sd">Input Files that I used in the code below:</span>
<span class="sd">luby_blocks.csv: Identifies which blocks of information are encoded in each droplet.</span>
<span class="sd">droplet_sequences.txt: Contains the sequencing results of the DNA droplets, from the fasta file you gave us. </span>
<span class="sd">Encoding Scheme:</span>
<span class="sd">A -&gt; 00</span>
<span class="sd">G -&gt; 01</span>
<span class="sd">C -&gt; 10</span>
<span class="sd">T -&gt; 11</span>

<span class="sd">Droplet Structure: Each droplet consists of:</span>
<span class="sd">Luby Index (16 bits)</span>
<span class="sd">Droplet Message (256 bits)</span>
<span class="sd">Error Correction Code (16 bits).&#39;&#39;&#39;</span>


<span class="c1"># Import necessary libraries</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="c1"># Load the CSV file into a DataFrame with correct splitting</span>
<span class="n">csv_file_path</span> <span class="o">=</span> <span class="s1">&#39;luby_blocks.csv&#39;</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file_path</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;drop&#39;</span><span class="p">])</span>

<span class="c1"># Split the &#39;drop&#39; column into separate &#39;drop&#39; and &#39;blocks&#39; columns</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;blocks&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;drop&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; - blocks: &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;drop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;drop&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; - blocks: &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Display the first few rows and column names of the DataFrame to verify the structure</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

<span class="c1"># Define a function to convert DNA sequence to binary</span>


<span class="k">def</span> <span class="nf">dna_to_binary</span><span class="p">(</span><span class="n">dna_sequence</span><span class="p">):</span>
    <span class="n">encoding</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="s1">&#39;00&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="s1">&#39;01&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="s1">&#39;10&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="s1">&#39;11&#39;</span><span class="p">}</span>
    <span class="n">binary_sequence</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">dna_sequence</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">encoding</span><span class="p">:</span>
            <span class="n">binary_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encoding</span><span class="p">[</span><span class="n">base</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Warning: Unexpected base &#39;</span><span class="si">{</span><span class="n">base</span><span class="si">}</span><span class="s2">&#39; found. Ignoring this base.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">binary_sequence</span><span class="p">)</span>


<span class="c1"># Load and parse the droplet_sequences.txt file (fasta)</span>
<span class="n">sequences</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">fasta_file_path</span> <span class="o">=</span> <span class="s1">&#39;droplet_sequences.txt&#39;</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fasta_file_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">droplet_number</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">):</span>
                <span class="n">header</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">droplet_number</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sequence</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">binary_sequence</span> <span class="o">=</span> <span class="n">dna_to_binary</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
                <span class="n">sequences</span><span class="p">[</span><span class="n">droplet_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">binary_sequence</span>

    <span class="c1"># Display a few decoded sequences for verification</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sequences</span><span class="o">.</span><span class="n">items</span><span class="p">())[:</span><span class="mi">5</span><span class="p">]:</span>
        <span class="c1"># Print the first 64 bits for brevity</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Droplet </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="p">[:</span><span class="mi">64</span><span class="p">]</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File not found: </span><span class="si">{</span><span class="n">fasta_file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Defined function to extract parts from binary sequence</span>


<span class="k">def</span> <span class="nf">extract_parts</span><span class="p">(</span><span class="n">binary_sequence</span><span class="p">):</span>
    <span class="n">luby_index</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">[:</span><span class="mi">16</span><span class="p">]</span>
    <span class="n">droplet_message</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">272</span><span class="p">]</span>
    <span class="n">error_correction_code</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">[</span><span class="mi">272</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">luby_index</span><span class="p">,</span> <span class="n">droplet_message</span><span class="p">,</span> <span class="n">error_correction_code</span>


<span class="c1"># Create a dictionary to hold the extracted parts for each droplet</span>
<span class="n">droplet_data</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">droplet_number</span><span class="p">,</span> <span class="n">binary_sequence</span> <span class="ow">in</span> <span class="n">sequences</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">luby_index</span><span class="p">,</span> <span class="n">droplet_message</span><span class="p">,</span> <span class="n">error_correction_code</span> <span class="o">=</span> <span class="n">extract_parts</span><span class="p">(</span>
        <span class="n">binary_sequence</span><span class="p">)</span>
    <span class="n">droplet_data</span><span class="p">[</span><span class="n">droplet_number</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;luby_index&#39;</span><span class="p">:</span> <span class="n">luby_index</span><span class="p">,</span>
        <span class="s1">&#39;droplet_message&#39;</span><span class="p">:</span> <span class="n">droplet_message</span><span class="p">,</span>
        <span class="s1">&#39;error_correction_code&#39;</span><span class="p">:</span> <span class="n">error_correction_code</span>
    <span class="p">}</span>

<span class="c1"># Display a few extracted parts for verification</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">droplet_data</span><span class="o">.</span><span class="n">items</span><span class="p">())[:</span><span class="mi">5</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Droplet </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: Luby Index - </span><span class="si">{</span><span class="n">value</span><span class="p">[</span><span class="s1">&#39;luby_index&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, Droplet Message - </span><span class="si">{</span><span class="n">value</span><span class="p">[</span><span class="s1">&#39;droplet_message&#39;</span><span class="p">][:</span><span class="mi">64</span><span class="p">]</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>

<span class="c1"># Initialize an array to hold the blocks</span>
<span class="n">n_blocks</span> <span class="o">=</span> <span class="mi">56</span>  <span class="c1"># Number of unique blocks of information</span>
<span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_blocks</span>

<span class="c1"># Define function to XOR two binary strings</span>


<span class="k">def</span> <span class="nf">xor_binary_strings</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;0&#39;</span> <span class="k">if</span> <span class="n">bit1</span> <span class="o">==</span> <span class="n">bit2</span> <span class="k">else</span> <span class="s1">&#39;1&#39;</span> <span class="k">for</span> <span class="n">bit1</span><span class="p">,</span> <span class="n">bit2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">)])</span>


<span class="c1"># Decode the blocks using the droplet data</span>
<span class="k">for</span> <span class="n">droplet_number</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">droplet_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Debug print to check the droplet number being processed</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing droplet: </span><span class="si">{</span><span class="n">droplet_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">block_indices_str</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;drop&#39;</span><span class="p">]</span> <span class="o">==</span>
                               <span class="sa">f</span><span class="s1">&#39;drop_n</span><span class="si">{</span><span class="n">droplet_number</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">][</span><span class="s1">&#39;blocks&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_indices_str</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No block indices found for droplet </span><span class="si">{</span><span class="n">droplet_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">block_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">block_indices_str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;[]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Droplet </span><span class="si">{</span><span class="n">droplet_number</span><span class="si">}</span><span class="s2">: Blocks </span><span class="si">{</span><span class="n">block_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing droplet </span><span class="si">{</span><span class="n">droplet_number</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">continue</span>

    <span class="n">decoded_message</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;droplet_message&#39;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">block_indices</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">n_blocks</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Error: Block index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2"> is out of range for droplet </span><span class="si">{</span><span class="n">droplet_number</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">blocks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">decoded_message</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">xor_binary_strings</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">decoded_message</span><span class="p">)</span>

<span class="c1"># Combine the blocks to form the final message</span>
<span class="n">final_binary_message</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">block</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">final_binary_message</span><span class="p">)</span>

<span class="c1"># Define function to convert binary to text</span>


<span class="k">def</span> <span class="nf">binary_to_text</span><span class="p">(</span><span class="n">binary_message</span><span class="p">):</span>
    <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">binary_message</span><span class="p">),</span> <span class="mi">8</span><span class="p">):</span>
        <span class="n">byte</span> <span class="o">=</span> <span class="n">binary_message</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">text</span>


<span class="c1"># Convert the final binary message to text</span>
<span class="n">final_text_message</span> <span class="o">=</span> <span class="n">binary_to_text</span><span class="p">(</span><span class="n">final_binary_message</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">final_text_message</span><span class="p">)</span>
</pre></div>
</body>
</html>
